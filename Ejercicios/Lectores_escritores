import threading
import time
import random

class AreaCompartida:
    def __init__(self):
        self.datos = []  # Área compartida de datos
        self.mutex = threading.Lock()  # Mutex para la exclusión mutua
        self.lectores_sem = threading.Semaphore(0)  # Semáforo para lectores
        self.escritores_sem = threading.Semaphore(1)  # Semáforo para escritores
        self.num_lectores = 0  # Contador de lectores en la sección crítica

    def empezar_lectura(self, lector):
        self.lectores_sem.acquire()
        with self.mutex:
            self.num_lectores += 1
            print(f"Lector {lector} ha empezado a leer. Lectores activos: {self.num_lectores}")
            if self.num_lectores == 1:
                self.escritores_sem.acquire()
        self.lectores_sem.release()

    def terminar_lectura(self, lector):
        with self.mutex:
            self.num_lectores -= 1
            print(f"Lector {lector} ha terminado de leer. Lectores activos: {self.num_lectores}")
            if self.num_lectores == 0:
                self.escritores_sem.release()

    def empezar_escritura(self, escritor):
        self.escritores_sem.acquire()
        print(f"Escritor {escritor} ha empezado a escribir.")

    def terminar_escritura(self, escritor):
        print(f"Escritor {escritor} ha terminado de escribir.")
        self.escritores_sem.release()

def lector(area_compartida, lector):
    while True:
        area_compartida.empezar_lectura(lector)
        # Realizar la lectura
        print(f"Lector {lector} está leyendo: {area_compartida.datos}")
        area_compartida.terminar_lectura(lector)
        time.sleep(random.uniform(1, 3))  # Simula un tiempo de lectura variable

def escritor(area_compartida, escritor):
    while True:
        area_compartida.empezar_escritura(escritor)
        # Realizar la escritura
        nuevo_dato = random.choice([1, 2, 3, 'a', 'b', 'c'])
        area_compartida.datos.append(nuevo_dato)
        print(f"Escritor {escritor} ha escrito: {nuevo_dato}")
        area_compartida.terminar_escritura(escritor)
        time.sleep(random.uniform(2, 4))  # Simula un tiempo de escritura variable

if __name__ == "__main__":
    area_compartida = AreaCompartida()

    # Crear lectores y escritores
    lectores = [threading.Thread(target=lector, args=(area_compartida, i)) for i in range(3)]
    escritores = [threading.Thread(target=escritor, args=(area_compartida, i)) for i in range(2)]

    # Iniciar los hilos
    [hilo.start() for hilo in lectores + escritores]

    # Esperar a que todos los hilos terminen
    [hilo.join() for hilo in lectores + escritores]
